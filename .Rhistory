################################################################################
#Load Libraries and suppress warnings
suppressWarnings(suppressMessages({
library(reshape2)
library(car)
library(stats)
library(ggfortify)
library(knitr)
library(kableExtra)
library(scales)
library(ggrepel)
library(Rtsne)
library(tidyverse)  # This will load readr, dplyr, tidyr, ggplot2 and some others
}))
# Reading the CSV files suppressing warnings
suppressWarnings(suppressMessages({
file_path <- "./Unzipped_data/"
files <- c(
"API_NY.GDP.MKTP.KD.ZG_DS2_en_csv_v2_5871639.csv",  # GDP growth (annual %)
"API_CM.MKT.LCAP.GD.ZS_DS2_en_csv_v2_5873240.csv",  # Market capitalization of listed domestic companies (% of GDP)
"API_FP.CPI.TOTL.ZG_DS2_en_csv_v2_5871597.csv",     # Inflation, consumer prices (annual %)
"API_GC.DOD.TOTL.GD.ZS_DS2_en_csv_v2_5872587.csv",  # Central government debt, total (% of GDP)
"API_BX.KLT.DINV.WD.GD.ZS_DS2_en_csv_v2_5994659.csv",  # Foreign direct investment, net inflows (% of GDP)
"API_SL.UEM.TOTL.NE.ZS_DS2_en_csv_v2_5996644.csv",   # Unemployment, total (% of total labor force) (national estimate)
"API_BN.CAB.XOKA.CD_DS2_en_csv_v2_5873206.csv",
"API_NE.GDI.TOTL.ZS_DS2_en_csv_v2_5873774.csv",
"API_FM.LBL.BMNY.GD.ZS_DS2_en_csv_v2_5873493.csv",
"API_GC.REV.XGRT.GD.ZS_DS2_en_csv_v2_5873527.csv",
"API_NY.GNS.ICTR.ZS_DS2_en_csv_v2_5873909.csv",
"API_FR.INR.LEND_DS2_en_csv_v2_5873491.csv",
"API_NE.CON.TOTL.ZS_DS2_en_csv_v2_5995951.csv"
)
data_list <- lapply(files, function(file) {
read_csv(paste0(file_path, file), skip = 3)
})
}))
################################################################################
# Heatmap business cycles
# Re-load the data
gdp_growth_data <- data_list[[1]]
# List of countries for which we want to plot the heatmap (adjust accordingly)
heatmap_business_cycles_countries <- c("United States", "Japan", "Germany", "China", "Greece", "Iceland", "Spain",
"Ireland", "Portugal", "Italy", "France", "United Kingdom", "Russian Federation",
"India", "Brazil", "Ukraine", "Australia", "Canada", "Mexico",
"Indonesia", "Turkey", "Estonia", "Saudi Arabia", "Sweden",
"Netherlands", "Switzerland", "Argentina", "Nigeria", "Poland", "Egypt")
# Select the data for the chosen countries and years 1960-2022
heatmap_data_selected <- data_list[[1]] %>%
filter(`Country Name` %in% heatmap_business_cycles_countries) %>%
select(`Country Name`, `1960`:`2022`) # Include years 2021 and 2022
# Reshape the data for plotting
heatmap_data_melted <- melt(heatmap_data_selected, id.vars = "Country Name")
# Create the heatmap with square tiles and white borders, and a distinct color for NA values
gdp_growth_heatmap <- ggplot(heatmap_data_melted, aes(x = variable, y = `Country Name`, fill = value)) +
geom_tile(color = "white") + # White borders and square tiles
scale_fill_gradientn(
colors = c("red", "orange", "white", "lightblue", "blue"), # Adjusted color scheme to blue shades
values = rescale(c(-10, 0, 15)), # Set the limits for the color gradient
limits = c(-10, 15), # Set the limits for the data
na.value = "grey50", # Color for NA values
name="GDP Growth (%)"
) +
scale_x_discrete(breaks = c("1960", "1970", "1980", "1990", "2000", "2010", "2020")) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 7), # Smaller text size for country names
axis.title.x = element_blank(), # Remove x-axis title
axis.title.y = element_blank(), # Remove y-axis title
plot.title = element_text(hjust = 0.5, size = 16, face = "bold") # Bolder, more prominent title
) +
labs(x = "", y = "", title = "Visualization of Business Cycles (1960-2022)") # Updated title
# Display the heatmap
print(gdp_growth_heatmap) #Enlarge the plot with the zoom function for interpretation
################################################################################
# Create dataframe for 2009
# Extract data for 2009 from the first six datasets
data_crises <- lapply(data_list[1:6], function(df) {
df %>%
select(`Country Name`, `2009`)
})
# Naming the datasets for clarity, corresponding to the first six datasets
names(data_crises) <- c("GDP Growth", "Market Capitalization", "Inflation", "Government Debt", "Foreign Investment", "Unemployment")
# Merging the datasets on Country Name
data_merged_crises <- Reduce(function(x, y) merge(x, y, by = "Country Name", all = TRUE), data_crises)
# Renaming columns for clarity
colnames(data_merged_crises) <- c("Country Name", "GDP Growth (2009)", "Market Capitalization (2009)", "Inflation (2009)", "Government Debt (2009)", "Foreign Investment (2009)", "Unemployment (2009)")
# Remove rows with any NA values
data_cleaned_crises <- na.omit(data_merged_crises)
# Create a copy of the data before standardization
data_cleaned_crises_original <- data_cleaned_crises
# Standardize the numeric variables
data_cleaned_crises[, -1] <- scale(data_cleaned_crises[, -1])
# View the standardized data frame
View(data_cleaned_crises)
################################################################################
# K-means clustering (with original standardized data)
# Create a copy of the data to preserve the original dataframe
data_for_clustering <- data_cleaned_crises
# Elbow Method to determine the optimal number of clusters
set.seed(123) # For reproducibility
wss <- numeric(15)
for (i in 1:15) {
kmeans_result <- kmeans(data_for_clustering[, -1], centers = i, nstart = 20)
wss[i] <- kmeans_result$tot.withinss
}
plot(1:15, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")
# Choose the optimal number of clusters (adjust based on the elbow plot)
optimal_k <- 3 # Based on the elbow plot
# K-means clustering using the optimal number of clusters
kmeans_result <- kmeans(data_for_clustering[, -1], centers = optimal_k, nstart = 20)
# Create a table with Country Name and Cluster assignment without altering the original data
cluster_table <- data_cleaned_crises[, c("Country Name"), drop = FALSE]
cluster_table$Cluster <- as.factor(kmeans_result$cluster)
# Order the table by cluster number
cluster_table_ordered <- cluster_table[order(cluster_table$Cluster), ]
# View the ordered table
View(cluster_table_ordered)
################################################################################
# PCA
# Perform PCA on the cleaned data for the crises year
pca_result_crises <- prcomp(data_cleaned_crises[, -1], center = TRUE, scale. = TRUE)
pca_result_crises$rotation
pca_summary_crises <- summary(pca_result_crises)
print(pca_summary_crises) # Check the importance of components
# Choose the first 2 principal components for k-means clustering
data_pca_crises <- as.data.frame(pca_result_crises$x[, 1:2])
################################################################################
# PCA plot interpretation
# Extract the loadings (coefficients for each principal component)
loadings <- pca_result_crises$rotation[, 1:2]
# Create a dataframe from the loadings for easier use with ggplot2
loadings_df <- as.data.frame(loadings)
loadings_df$variable <- rownames(loadings)
# Plot the loadings as arrows, starting from the origin
plot_PCA_interpretation <- ggplot() +
geom_segment(data = loadings_df, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(type = "closed", length = unit(0.1, "inches")),
color = "black") +  # Black arrows with smaller tips
geom_text(data = loadings_df, aes(x = PC1, y = PC2, label = variable),
nudge_x = 0.05, nudge_y = 0.05, color = "black") +  # Add labels for each variable
theme_minimal() +
labs(title = "Plot of PCA with Macroeconomic Indicators",
x = "Principal Component 1 (29%)",
y = "Principal Component 2 (24%)")
print(plot_PCA_interpretation) #Enlarge the plot with the zoom function for interpretation
################################################################################
# K-means clustering (with PCA)
# Clustering with k-means on the 2 PCA components
set.seed(123) # Setting seed for reproducibility
wss <- numeric(15)
for (i in 1:15) {
kmeans_result_crises <- kmeans(data_pca_crises, centers = i, nstart = 20) # Use the correct variable
wss[i] <- kmeans_result_crises$tot.withinss
}
plot(1:15, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")
# Determine the optimal number of clusters from the elbow plot
optimal_k <- 3 # Adjust based on the elbow plot
# K-means clustering on the two PCA components
kmeans_result_crises <- kmeans(data_pca_crises, centers = optimal_k, nstart = 20) # Use the correct variable
# Add the cluster assignment to the original data frame
data_cleaned_crises$Cluster <- as.factor(kmeans_result_crises$cluster)
# Add the first two principal components to the data frame for plotting
data_cleaned_crises$PCA1 <- pca_result_crises$x[, 1] # Correct pca_result_crises
data_cleaned_crises$PCA2 <- pca_result_crises$x[, 2] # Correct pca_result_crises
# Improved color scheme for clusters
# Make sure the number of colors corresponds to the number of clusters
color_spectrum <- scale_color_manual(values = c("red", "orange", "blue")[1:optimal_k])
# Create a ggplot using the first two principal components for visualization
plot_PCA_k_means <- ggplot(data_cleaned_crises, aes(x = PCA1, y = PCA2, color = Cluster)) + # Use the correct data frame
geom_point(alpha = 0.6, size = 2, shape = 16) +
color_spectrum +
labs(title = "K-Means Clustering on Principal Components (PC1 and PC2)",
x = "Principal Component 1 (29%)",
y = "Principal Component 2 (24%)") +
theme_minimal() +
theme(legend.position = "right")
# Use ggrepel to avoid overlapping text
plot_PCA_k_means <- plot_PCA_k_means + geom_text_repel(aes(label = `Country Name`), size = 3, max.overlaps = Inf)
# Print the plot
print(plot_PCA_k_means) #Enlarge the plot with the zoom function for interpretation
# Create a table with Country Name and Cluster assignment
cluster_table_pca <- data_cleaned_crises %>%
select(`Country Name`) %>%
mutate(Cluster = as.factor(kmeans_result_crises$cluster))
# Order the table by cluster number and view it
cluster_table_ordered_pca <- cluster_table_pca %>%
arrange(Cluster)
View(cluster_table_ordered_pca)
################################################################################
# Hierarchical clustering (without PCA)
# Hierarchical Clustering on the original data
dist_matrix <- dist(data_for_clustering[, -1], method = "euclidean")
hc_crises <- hclust(dist_matrix, method = "complete")
# Plot the dendrogram with adjusted text size
par(cex = 0.5)  # Adjusts the text size
plot(hc_crises, labels = data_for_clustering$`Country Name`, main = "Hierarchical Clustering Dendrogram", xlab = "", sub = "") #Enlarge the plot with the zoom function for interpretation
################################################################################
#Load Libraries and suppress warnings
suppressWarnings(suppressMessages({
library(reshape2)
library(car)
library(stats)
library(ggfortify)
library(knitr)
library(kableExtra)
library(scales)
library(ggrepel)
library(Rtsne)
library(tidyverse)  # This will load readr, dplyr, tidyr, ggplot2 and some others
}))
# Reading the CSV files suppressing warnings
suppressWarnings(suppressMessages({
file_path <- "./Unzipped_data/"
files <- c(
"API_NY.GDP.MKTP.KD.ZG_DS2_en_csv_v2_5871639.csv",  # GDP growth (annual %)
"API_CM.MKT.LCAP.GD.ZS_DS2_en_csv_v2_5873240.csv",  # Market capitalization of listed domestic companies (% of GDP)
"API_FP.CPI.TOTL.ZG_DS2_en_csv_v2_5871597.csv",     # Inflation, consumer prices (annual %)
"API_GC.DOD.TOTL.GD.ZS_DS2_en_csv_v2_5872587.csv",  # Central government debt, total (% of GDP)
"API_BX.KLT.DINV.WD.GD.ZS_DS2_en_csv_v2_5994659.csv",  # Foreign direct investment, net inflows (% of GDP)
"API_SL.UEM.TOTL.NE.ZS_DS2_en_csv_v2_5996644.csv",   # Unemployment, total (% of total labor force) (national estimate)
"API_BN.CAB.XOKA.CD_DS2_en_csv_v2_5873206.csv",
"API_NE.GDI.TOTL.ZS_DS2_en_csv_v2_5873774.csv",
"API_FM.LBL.BMNY.GD.ZS_DS2_en_csv_v2_5873493.csv",
"API_GC.REV.XGRT.GD.ZS_DS2_en_csv_v2_5873527.csv",
"API_NY.GNS.ICTR.ZS_DS2_en_csv_v2_5873909.csv",
"API_FR.INR.LEND_DS2_en_csv_v2_5873491.csv",
"API_NE.CON.TOTL.ZS_DS2_en_csv_v2_5995951.csv"
)
data_list <- lapply(files, function(file) {
read_csv(paste0(file_path, file), skip = 3)
})
}))
################################################################################
# Heatmap business cycles
# Re-load the data
gdp_growth_data <- data_list[[1]]
# List of countries for which we want to plot the heatmap (adjust accordingly)
heatmap_business_cycles_countries <- c("United States", "Japan", "Germany", "China", "Greece", "Iceland", "Spain",
"Ireland", "Portugal", "Italy", "France", "United Kingdom", "Russian Federation",
"India", "Brazil", "Ukraine", "Australia", "Canada", "Mexico",
"Indonesia", "Turkey", "Estonia", "Saudi Arabia", "Sweden",
"Netherlands", "Switzerland", "Argentina", "Nigeria", "Poland", "Egypt")
# Select the data for the chosen countries and years 1960-2022
heatmap_data_selected <- data_list[[1]] %>%
filter(`Country Name` %in% heatmap_business_cycles_countries) %>%
select(`Country Name`, `1960`:`2022`) # Include years 2021 and 2022
# Reshape the data for plotting
heatmap_data_melted <- melt(heatmap_data_selected, id.vars = "Country Name")
# Create the heatmap with square tiles and white borders, and a distinct color for NA values
gdp_growth_heatmap <- ggplot(heatmap_data_melted, aes(x = variable, y = `Country Name`, fill = value)) +
geom_tile(color = "white") + # White borders and square tiles
scale_fill_gradientn(
colors = c("red", "orange", "white", "lightblue", "blue"), # Adjusted color scheme to blue shades
values = rescale(c(-10, 0, 15)), # Set the limits for the color gradient
limits = c(-10, 15), # Set the limits for the data
na.value = "grey50", # Color for NA values
name="GDP Growth (%)"
) +
scale_x_discrete(breaks = c("1960", "1970", "1980", "1990", "2000", "2010", "2020")) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 7), # Smaller text size for country names
axis.title.x = element_blank(), # Remove x-axis title
axis.title.y = element_blank(), # Remove y-axis title
plot.title = element_text(hjust = 0.5, size = 16, face = "bold") # Bolder, more prominent title
) +
labs(x = "", y = "", title = "Visualization of Business Cycles (1960-2022)") # Updated title
# Display the heatmap
print(gdp_growth_heatmap) #Enlarge the plot with the zoom function for interpretation
################################################################################
# Create dataframe for 2009
# Extract data for 2009 from the first six datasets
data_crises <- lapply(data_list[1:6], function(df) {
df %>%
select(`Country Name`, `2009`)
})
# Naming the datasets for clarity, corresponding to the first six datasets
names(data_crises) <- c("GDP Growth", "Market Capitalization", "Inflation", "Government Debt", "Foreign Investment", "Unemployment")
# Merging the datasets on Country Name
data_merged_crises <- Reduce(function(x, y) merge(x, y, by = "Country Name", all = TRUE), data_crises)
# Renaming columns for clarity
colnames(data_merged_crises) <- c("Country Name", "GDP Growth (2009)", "Market Capitalization (2009)", "Inflation (2009)", "Government Debt (2009)", "Foreign Investment (2009)", "Unemployment (2009)")
# Remove rows with any NA values
data_cleaned_crises <- na.omit(data_merged_crises)
# Create a copy of the data before standardization
data_cleaned_crises_original <- data_cleaned_crises
# Standardize the numeric variables
data_cleaned_crises[, -1] <- scale(data_cleaned_crises[, -1])
# View the standardized data frame
View(data_cleaned_crises)
################################################################################
# K-means clustering (with original standardized data)
# Create a copy of the data to preserve the original dataframe
data_for_clustering <- data_cleaned_crises
# Elbow Method to determine the optimal number of clusters
set.seed(123) # For reproducibility
wss <- numeric(15)
for (i in 1:15) {
kmeans_result <- kmeans(data_for_clustering[, -1], centers = i, nstart = 20)
wss[i] <- kmeans_result$tot.withinss
}
plot(1:15, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")
# Choose the optimal number of clusters (adjust based on the elbow plot)
optimal_k <- 3 # Based on the elbow plot
# K-means clustering using the optimal number of clusters
kmeans_result <- kmeans(data_for_clustering[, -1], centers = optimal_k, nstart = 20)
# Create a table with Country Name and Cluster assignment without altering the original data
cluster_table <- data_cleaned_crises[, c("Country Name"), drop = FALSE]
cluster_table$Cluster <- as.factor(kmeans_result$cluster)
# Order the table by cluster number
cluster_table_ordered <- cluster_table[order(cluster_table$Cluster), ]
# View the ordered table
View(cluster_table_ordered)
################################################################################
# PCA
# Perform PCA on the cleaned data for the crises year
pca_result_crises <- prcomp(data_cleaned_crises[, -1], center = TRUE, scale. = TRUE)
pca_result_crises$rotation
pca_summary_crises <- summary(pca_result_crises)
print(pca_summary_crises) # Check the importance of components
# Choose the first 2 principal components for k-means clustering
data_pca_crises <- as.data.frame(pca_result_crises$x[, 1:2])
################################################################################
# PCA plot interpretation
# Extract the loadings (coefficients for each principal component)
loadings <- pca_result_crises$rotation[, 1:2]
# Create a dataframe from the loadings for easier use with ggplot2
loadings_df <- as.data.frame(loadings)
loadings_df$variable <- rownames(loadings)
# Plot the loadings as arrows, starting from the origin
plot_PCA_interpretation <- ggplot() +
geom_segment(data = loadings_df, aes(x = 0, y = 0, xend = PC1, yend = PC2),
arrow = arrow(type = "closed", length = unit(0.1, "inches")),
color = "black") +  # Black arrows with smaller tips
geom_text(data = loadings_df, aes(x = PC1, y = PC2, label = variable),
nudge_x = 0.05, nudge_y = 0.05, color = "black") +  # Add labels for each variable
theme_minimal() +
labs(title = "Plot of PCA with Macroeconomic Indicators",
x = "Principal Component 1 (29%)",
y = "Principal Component 2 (24%)")
print(plot_PCA_interpretation) #Enlarge the plot with the zoom function for interpretation
################################################################################
# K-means clustering (with PCA)
# Clustering with k-means on the 2 PCA components
set.seed(123) # Setting seed for reproducibility
wss <- numeric(15)
for (i in 1:15) {
kmeans_result_crises <- kmeans(data_pca_crises, centers = i, nstart = 20) # Use the correct variable
wss[i] <- kmeans_result_crises$tot.withinss
}
plot(1:15, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")
# Determine the optimal number of clusters from the elbow plot
optimal_k <- 3 # Adjust based on the elbow plot
# K-means clustering on the two PCA components
kmeans_result_crises <- kmeans(data_pca_crises, centers = optimal_k, nstart = 20) # Use the correct variable
# Add the cluster assignment to the original data frame
data_cleaned_crises$Cluster <- as.factor(kmeans_result_crises$cluster)
# Add the first two principal components to the data frame for plotting
data_cleaned_crises$PCA1 <- pca_result_crises$x[, 1] # Correct pca_result_crises
data_cleaned_crises$PCA2 <- pca_result_crises$x[, 2] # Correct pca_result_crises
# Improved color scheme for clusters
# Make sure the number of colors corresponds to the number of clusters
color_spectrum <- scale_color_manual(values = c("red", "orange", "blue")[1:optimal_k])
# Create a ggplot using the first two principal components for visualization
plot_PCA_k_means <- ggplot(data_cleaned_crises, aes(x = PCA1, y = PCA2, color = Cluster)) + # Use the correct data frame
geom_point(alpha = 0.6, size = 2, shape = 16) +
color_spectrum +
labs(title = "K-Means Clustering on Principal Components (PC1 and PC2)",
x = "Principal Component 1 (29%)",
y = "Principal Component 2 (24%)") +
theme_minimal() +
theme(legend.position = "right")
# Use ggrepel to avoid overlapping text
plot_PCA_k_means <- plot_PCA_k_means + geom_text_repel(aes(label = `Country Name`), size = 3, max.overlaps = Inf)
# Print the plot
print(plot_PCA_k_means) #Enlarge the plot with the zoom function for interpretation
# Create a table with Country Name and Cluster assignment
cluster_table_pca <- data_cleaned_crises %>%
select(`Country Name`) %>%
mutate(Cluster = as.factor(kmeans_result_crises$cluster))
# Order the table by cluster number and view it
cluster_table_ordered_pca <- cluster_table_pca %>%
arrange(Cluster)
View(cluster_table_ordered_pca)
